# 类加载

### 类加载的几个阶段

加载 --> 验证（Verification) --> 准备 (Preparation) --> 解析 (Resolution)
--> 初始化 (Initiallization) --> 使用 (Use） --> 卸载 (Unloading)

解析阶段有时候会在初始化后再执行

#### 加载阶段的执行含义

**加载** 分为3个部分

1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将字节流所代表的静态存储结构转化为方法区的运行时数据结构 // java7 之前是 PermSize  , java8: metaSpace
3. 在内存中生成一个代表这个类的java.lang.Class 对象， 作为方法区这个类的各种数据的访问入口

*验证**  确保Class文件服务当前虚拟机要求

1. 文件格式验证。 包括是否以0xCAFFBABE开头，版本号是否可以当前虚拟机执行，常量池常量类型是否支持等等。。。
2. 元数据验证。 针对语义分析，是否有父类，父类是否继承了不允许继承的类是否抽象，子类是否是实现接口中的方法等等。。
3. 字节码验证。 确认数据流和控制流分析远程是合法的，并对类的方法进行校验，保证类方法在运行期间不会做出危害虚拟机安全的事件
4. 符号引用。  将符号引用转化为直接引用，对引用做匹配性校验。如方法的访问性，是否可以通过全量名找到对应的类 

**准备** 正式为类变量分配内存并设置类变量的初始值

这个分配内存的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量会在对象实例化时随着对象一起配置到java堆中。例如： 

public static int value = 123; 准备阶段的数值是0, 而不是123, 123这个putstatic指令会被放置到init<>方法中。

**解析** 将常量池内的符号引用替换为直接引用的过程

1. 类和接口解析
2. 字段解析
3. 类方法解析
4. 接口方法解析

**初始化** 

<p>
类的初始化:有且只有的5种对类初始化的情况
1. 遇到 new, putstatic, getstatic, invokestatic 这四个指令时，需要先触发类的初始化。 关键字的常用场景： 使用new初始化实例对象，获取静态
变量，为静态变量赋值时（被final修饰的除外，已经被放到常量池中），  掉哟过一个类静态方法时
2. 使用 java.lang.reflect 对类进行反射调用的时候，如果类没有初始化，则触发初始化
3. 当初始化一个类的时候，如果父类没有初始化，会先初始化父类
4. 虚拟机启动时，需要用户指定一个主类（包含main方法的类）， 虚拟机会先初始化这个主类
5. 使用ＪＤＫ1.7动态语言支持时， 如果一个java.lang.invoke.MethodHandle 实例最后的解析结果是REF_static, REF_putstatic, REF_invokestatic
的方法句柄，并且这个方法没有被初始化，则需要先进行初始化


#### attention 

1. 当类中含义初始化变量以及有参构造方法，那么会先初始化变量，然后在执行构造方法
```java
public class Test{
    private String name = "xx";
    
    public Test(){}
    
    public Test(String name){this.name = name;}
    
    public static void main(String[] args){
        // 会先初始化name=xx,然后在执行构造方法使name=null
      new Test(null); 
    }
}



```
  
